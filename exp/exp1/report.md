# 人工智能基础实验1报告

***

梁峻滔 PB19051175

***

[toc]

## 1 星际迷踪-A*搜索问题

### 算法思想

#### A*搜索思想

将一种星球布局作为一个状态(节点), 状态转移最多有四种可能: 飞船向上/下/左/右移动一格, 状态转移前进行边界、黑洞、隧道的检查, 然后判断移动是否可行. 一种星球布局(在实现时就是一个矩阵)就是一个状态, 可以直接将一个状态作为A*搜索中的一个节点, 但是为了方便获取移动操作序列、生成后继节点、插入fringe优先队列时获取f值等, 用一个结构体包含布局矩阵以及一些必要的信息来作为一个节点.

采用一个优先队列fringe, 每次迭代时从fringe中取出第一个节点, 检查是否是目标状态, 如果是就返回, 如果不是就计算所有可能的后继状态, 然后将其加入到fringe队列中, 进行下一轮迭代.

优先队列fringe是关于 f = g + h 值的优先队列, 其中 g 为树访问深度(例如, 初始状态深度为0, 初始状态的后继状态深度为1, 依此类推), h为自定义的启发式函数, 是一个状态到一个数值的映射, h值含义是对一个状态离目标状态的距离的一个估计. 

根据课堂内的讨论, 当自定义启发式函数 h 是可采纳的(admissible)时, A*搜索方法可以找到最优解(即飞船移动的步数最少).

#### IDA*搜索思想

与A*搜索采用一个fringe优先队列存放所有待探索节点相比, IDA\*搜索是通过使用深度优先搜索的策略和使用一个threshold来控制空间开销. 当一个节点的 f 值超过给定 threshold 时就认为该节点不可能在最短路径上, 就不需要继续从该节点出发探索其后继节点了. threshold初始化为初始状态的h值, 之后每次迭代后选择 f 值超过该threshold值的所有节点的最小的 f 值作为新的threshold.

启发式函数具有一致性和可采纳性时可以保证IDA*搜索找到最短路径.

#### 两个启发式函数

##### h1 错位的星球数

###### 描述

设 n 是一个节点, 则 h(n) = 节点n对应矩阵中位置与target矩阵位置不相同的星球数(不包括黑洞和飞船)

###### 可采纳性

飞船移动一次只能改变一个星球的位置, 一个错位的星球最少也要一次移动才能到达target状态, 所以飞船所需移动次数必定不小于错位星球数, 即满足对任意的 n 都有 $h(n) \leq h^*(n)$ 成立.

##### h2 经过修正的曼哈顿距离

###### 描述

曼哈顿距离不是可采纳的是因为有隧道的存在. 例如(0, 2)到(4, 2)的曼哈顿距离为4, 但是实际上飞船从(0, 2)到(4, 2)经过隧道只需一步就可到达. 因此如果直接使用曼哈顿距离的话就会有 $h > h^*$ 的情况, 不满足可采纳性.

观察可知, 如果经过两次隧道, 步数肯定比原来的曼哈顿距离还要多. 因此比实际距离小的情况肯定最多只经过一次隧道. 

那么就对于每个星球, 考虑从它出发直接到target位置的曼哈顿距离、从它出发先到(0, 2)经过隧道到(4, 2)再到target位置的曼哈顿距离、从它出发先到(4, 2)经过隧道到(0, 2)再到target位置的曼哈顿距离、从它出发先到(2, 0)经过隧道到(2, 4)再到target位置的曼哈顿距离、从它出发先到(2, 4)经过隧道到(2, 0)再到target位置的曼哈顿距离, 从中取最小值作为估计距离. 再对每个星球的估计距离求和作为该节点的h值.

###### 可采纳性

移动一个星球到其target位置所需要经过的最少步数必定为上述五种情况之一. 而飞船的每次移动实际上等价于移动一个星球. 因此每个星球都必须经过这样的移动. 所以有$h(n) \leq h^*(n)$, 满足可采纳性. 

### 测试分析

#### A_h1

| 样例编号 | 移动序列                         | 总步数 | 运行时间(s) |
| -------- | -------------------------------- | ------ | ----------- |
| 00       | DDRUR                            | 5      | 0.000212    |
| 01       | ULLUULDD                         | 8      | 0.000204    |
| 02       | DDLUULLURR                       | 10     | 0.000143    |
| 03       | DLDRRURRRUUURR                   | 14     | 0.0013      |
| 04       | LUUURULLURDDRDR                  | 15     | 0.003912    |
| 05       | LLUURRRUURDDDDLUURDD             | 20     | 0.005866    |
| 06       | DRDLLULULUUURDRURDRDRRR          | 23     | 0.012595    |
| 07       | URRRRDLLLLDRRRRDLLLLDRRRR        | 25     | 0.002686    |
| 08       | DDRULLLLDRUUUULDRRRRULDDDDR      | 27     | 0.042884    |
| 09       | RRRRDRUUULDLDLLDRDLUUUURRURR     | 28     | 0.627333    |
| 10       | DDRRUUUULLULLUULLLLLUURRDDDDRR   | 30     | 0.033719    |
| 11       | DRUURDRRDRUULDLULDLDRDLDRURDRURD | 32     | 2.88267     |

#### A_h2

| 样例编号 | 移动序列                         | 总步数 | 运行时间(s) |
| -------- | -------------------------------- | ------ | ----------- |
| 00       | DDRUR                            | 5      | 0.000446    |
| 01       | ULLUULDD                         | 8      | 0.000656    |
| 02       | DDLUULLURR                       | 10     | 0.000407    |
| 03       | DLDRRURRRUUURR                   | 14     | 0.002299    |
| 04       | LUUURULLURDDRDR                  | 15     | 0.002106    |
| 05       | LLUURRRUURDDDDLUURDD             | 20     | 0.002225    |
| 06       | DRDLLULULUUURDRURDRDRRR          | 23     | 0.010562    |
| 07       | URRRRDLLLLDRRRRDLLLLDRRRR        | 25     | 0.005728    |
| 08       | DLLLDRUUUULDRRRRULDDDDRULDR      | 27     | 0.009185    |
| 09       | RDRDLUUUURRUUURDRUUULDLDDDRR     | 28     | 0.104929    |
| 10       | DDRRUUUULLULLUULLLLLUURRDDDDRR   | 30     | 0.003768    |
| 11       | DRUURDRRDRUULDLULDLDRDLDRURDRURD | 32     | 0.132074    |

#### IDA_h1

| 样例编号 | 移动序列                         | 总步数 | 运行时间(s) |
| -------- | -------------------------------- | ------ | ----------- |
| 00       | DDRUR                            | 5      | 0.001274    |
| 01       | ULLUULDD                         | 8      | 0.000827    |
| 02       | DDLUULLURR                       | 10     | 0.000805    |
| 03       | DLDRRURRRUUURR                   | 14     | 0.002379    |
| 04       | LUUURULLURDDRDR                  | 15     | 0.007638    |
| 05       | LLUURRRUURDDDDLUURDD             | 20     | 0.010275    |
| 06       | DRDLLULULUUURDRURDRDRRR          | 23     | 0.020813    |
| 07       | URRRRDLLLLDRRRRDLLLLDRRRR        | 25     | 0.002035    |
| 08       | DDRULLLLDRUUUULDRRRRULDDDDR      | 27     | 0.083647    |
| 09       | RDRURRDRUUULDLDLDDLUUUURRURR     | 28     | 1.65614     |
| 10       | DDRRUUUULLULLUULLLLLUURRDDDDRR   | 30     | 0.075578    |
| 11       | DRUURDRRDRUULDLULDLDRDLDRURDRURD | 32     | 4.8206      |

#### IDA_h2

| 样例编号 | 移动序列                         | 总步数 | 运行时间(s) |
| -------- | -------------------------------- | ------ | ----------- |
| 00       | DDRUR                            | 5      | 0.001637    |
| 01       | ULLUULDD                         | 8      | 0.001634    |
| 02       | DDLUULLURR                       | 10     | 0.002012    |
| 03       | DLDRRURRRUUURR                   | 14     | 0.003709    |
| 04       | LUUURULLURDDRDR                  | 15     | 0.005515    |
| 05       | LLUURRRUURDDDDLUURDD             | 20     | 0.002763    |
| 06       | DRDLLULULUUURDRURDRDRRR          | 23     | 0.014256    |
| 07       | URRRRDLLLLDRRRRDLLLLDRRRR        | 25     | 0.008613    |
| 08       | DDRULLLLDRUUUULDRRRRULDDDDR      | 27     | 0.008354    |
| 09       | RDRDLUUUURRUUURDRUUULDLDDDRR     | 28     | 0.374311    |
| 10       | DDRRUUUULLULLUULLLLLUURRDDDDRR   | 30     | 0.010116    |
| 11       | DRUURDRRDRUULDLULDLDRDLDRURDRURD | 32     | 0.283862    |

#### 结论

观察可以发现采用不同的启发式函数, 找到的最短路径可能不一样, 例如对于样例09, 采用h1时找到的最短路径是 RDRURRDRUUULDLDLDDLUUUURRURR, 采用h2时找到的最短路径是 RDRDLUUUURRUUURDRUUULDLDDDRR, 但长度相同.

对比运行时间可以观察到, 对于同一种搜索算法, 采用不同启发式函数时可能会对运行时间产生较大影响. 对于简单样例, 例如00, 01, 02, 采用 h1 的运行时间可能会比 h2 稍好, 但是对于复杂样例, 例如11, 10, 09等, 采用 h2 的运行时间反而显著优于 h1. 而 h2 的估计更接近于一个节点到target节点的真是距离.

而采用相同启发式函数时, 虽然IDA*的理论空间开销比A\*搜索小, 但IDA\*的实际运行时间一般比A\*的多. 由于我的IDA\*实现时采用了递归版本的算法, 多出的运行时间里不排除递归调用的开销. 

### 一些优化

* 计算h2时, 由于要先找到一个星球在当前矩阵和target矩阵中的位置, 所以正常时间开销是$O(n^4)$, 但是可以利用每个星球具有一个唯一的编号, 而且编号的绝对值大小为0~24, 先遍历target矩阵把每个星球的位置与其编号(数组下标)对应起来, 然后在遍历当前矩阵计算时, 可以在常数时间内得到每个星球的target位置, 时间开销可降低为$O(n^2)$.
* 优先队列采用C++ STL的priority_queue, 由于其底层是使用堆来实现, 所以插入队列的时间开销可降低为$O(n\ log\ n)$.
* 将深度、h值、矩阵中飞船位置等信息在节点结构体中维护, 减少重复计算带来的时间开销. 例如, 生成后继节点时, 如果节点中不含有飞船位置信息, 则需要先遍历矩阵找到飞船, 再考察后继状态, 但如果已经保存了飞船位置信息, 则可以直接用, 然后在生成后继节点时, 后继节点的飞船位置也可以根据当前飞船位置直接常数时间内计算出来.

## 2 CSP-工人值班调度问题

### 问题要求和理解

需要满足的约束条件:

1. 每个工人每周必须休息2天或以上
2. 每个工人每周不可以连续休息3天(不考虑跨周情况)
3. 一周七天每天都要安排工人值班
4. ***每天至少要有3个人值班***
5. 每天至少要有一名级别为 senior 的工人值班
6. ***一些具体的工人之间的矛盾***

其中1, 2, 3, 5对于要解决的两个问题都是一样的, `要求每天值班的人数也可以在源码中指定`, 为了简便直接在源码实现中完成, 这些参数不使用输入文件指定. 而是在源码中设置:

![image-20220505203139665](D:\USTC\AI2022\Lab\Lab1\report.assets\image-20220505203139665.png)

规定输入文件格式如下:

```
工人人数n
senior
junior
... // n行表示每个工人的级别, 顺序表示工人编号
有矛盾的工人对数m
1 5
2 6
8 10
... // m行表示有矛盾的工人对
```

要求解决的两个问题的输入文件格式如下:

input1.txt

```
7
senior
senior
junior
junior
junior
junior
junior
3
1 4
2 3
3 6
```

input2.txt

```
10
senior
senior
junior
junior
junior
junior
junior
senior
junior
senior
3
1 5
2 6
8 10
```

### 状态和变量表示

回顾CSP的两个要素: 状态和变量. 需要先定义问题中的变量(不等同于实现程序中的变量), 状态就是变量的一组赋值(对于非goal状态, 可以有变量未赋值). 对于本问题, 可以使用一个二维矩阵state(一周的天数×工人数)来表示状态, 矩阵中的每个元素就是一个变量, 一个变量只有两种取值: true/false. state\[i]\[j] 为 true 时表示安排工人 j 在一周中第 i 天值班. 实现时为了方便区分未赋值和false, 采用一个枚举类来表示变量的取值. 枚举类定义如下:

```c++
enum st {
    none,
    duty,
    rest
};  // 变量的取值: 值班, 休息, 未赋值
```

这样定义变量和状态也方便检查是否满足各个约束.

### 约束表示

设定一些全局变量来指定每天要求的最少值班人数等, 用一个pair数组存放有矛盾的工人对, 在算法执行过程中逐个检查状态是否满足给定约束(即源码体现约束).

### 赋值过程

#### 基本过程

每个工人在每一天都有两种可能的状态: 值班/躺. 假设有10个工人, 那么 state 就是一个10×7矩阵. 按一下顺序赋值:

周日: 工人1, 工人2, ...

周一: 工人1, 工人2, ...

...

枚举每位工人在每天可能的状态. 如果全部枚举, 枚举的状态数就有 $2^{70}$ 种.

#### 前向检验思想  

维护一个工人可用状态(wst)表, 方便查询在当前赋值状态下, 某个工人在某一天是必须值班(duty), 还是必须休息(rest), 还是两者都可(both). 初始时所有工人每天的可用状态都是both. 然后每赋一次值, 就根据所有给定的约束更新一次工人可用状态, 例如给一个工人在某一天赋值为值班后, 那么就要将与该工人有矛盾的其他工人在这天的wst都设置为必须休息等. 根据 wst 表进行下一次赋值. 具体更新细节比较复杂, 可考察源码, 这里不详细说明.

如果不使用前向检验或者其他优化方法, 那么整个状态空间的大小为 $O(2^{49})$ 和 $O(2^{70})$, 使用前向检验后可以在枚举过程中进行一些剪枝, 缩减状态空间. 但是相应地维护前向检验中所需的剩余取值信息也需要一定的时间和空间开销.

### 两个具体问题的解

[i, j]为1表示工人 i 在一周中第 j 天(j = 0表示周日)值班, 为0表示休息.

#### 1

矩阵形式

![image-20220505203406246](D:\USTC\AI2022\Lab\Lab1\report.assets\image-20220505203406246.png)

周几-编号形式

![image-20220506221928772](D:\USTC\AI2022\Lab\Lab1\report.assets\image-20220506221928772.png)

#### 2

矩阵形式

![image-20220505203428140](D:\USTC\AI2022\Lab\Lab1\report.assets\image-20220505203428140.png)

周几-编号形式

![image-20220506222009788](D:\USTC\AI2022\Lab\Lab1\report.assets\image-20220506222009788.png)

### Local Search算法

可以通过 Hill-climbing 方法解决, 变量和状态表示仍采用上述表示. 假设初始状态为让所有工人每天都值班. 每次迭代都随机选取一个变量, 改变其赋值(从值班改为休息, 从休息改为值班), 如果违反的约束数量减少了, 就采纳, 进行下一轮迭代. 否则不改变所选取变量的赋值, 随机选取另一个变量考察是否可以改变赋值. 

```pseudocode
h(state) the number of violated constraints
is_goal(state) goal test
procedure HillClimbing(state)
	loop 
		if is_goal(state) then
        	output state
        	break
		end if
		randomly select a variable v of state
		let next be the successor of state after changing v's value
    	if h(next) < h(state) then
    		next = state
    	end if
    end loop
end procedure
```